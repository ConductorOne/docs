---
title: The hardest parts of connector development
og:title: The hardest parts of connector development - ConductorOne
og:description: Building a connector is straightforward once you understand the target system's access model. Getting to that understanding is the hard part.
description: Guidance for working through the challenges of connector development.
sidebarTitle: "Hardest parts"
---

Building a connector is straightforward once you understand the target system's access model. Getting to that understanding is the hard part.

This page acknowledges the challenges you'll face and offers guidance for working through them.

## Understanding the access model

Every SaaS application has its own way of organizing access. Some use roles. Some use groups. Some use both. Some use neither and have per-resource permissions.

**The challenge:** Before writing any code, you need to answer:
- What can users access? (resources)
- How is access organized? (groups, roles, permissions)
- How do users get access? (membership, assignment, invitation)

**What helps:**
- Read the target system's admin documentation, not just the API docs
- Look for "access management" or "permissions" sections
- Try the UI yourself - how would an admin grant access?
- If stuck, ask in discussions - others have likely figured it out

## Mapping to the baton model

Once you understand the target system, you need to express it in baton's model: resources, entitlements, and grants.

**The challenge:** The mapping isn't always obvious.
- Is a "team" a group or a resource?
- Is "admin" a role or a permission on a resource?
- If users can have different roles in different projects, how do you model that?

**What helps:**
- Start with users - they're always `TRAIT_USER`
- Things users can be "members of" are usually `TRAIT_GROUP`
- Things users can be "assigned to" are usually `TRAIT_ROLE`
- When in doubt, look at similar connectors for patterns

## Finding the right API endpoints

APIs aren't designed for access management - they're designed for the application. Finding the endpoints that reveal "who has access to what" takes detective work.

**The challenge:**
- Membership endpoints might be under `/groups/{id}/members` or `/users/{id}/groups` or both
- Some APIs paginate, some don't
- Some return full objects, some return just IDs
- Some require special scopes or permissions

**What helps:**
- Search the API docs for "member", "permission", "role", "grant"
- Use the API explorer if one exists
- Check the OAuth scopes - they often hint at what data is available
- Look at what other tools (Terraform providers, SDK clients) do

## Handling pagination correctly

Every API paginates differently. Getting pagination wrong means missing data.

**The challenge:**
- Cursor-based vs offset-based vs page-number
- Different response shapes (items in `data` vs `results` vs top-level array)
- Rate limits that interact with pagination
- APIs that return inconsistent page sizes

**What helps:**
- The SDK's `pagination.Bag` handles most cases
- Test with accounts that have more data than one page
- Log page counts during development to verify you're getting everything

## Provisioning without breaking things

Granting and revoking access touches real permissions. A bug here can lock people out or give access they shouldn't have.

**The challenge:**
- Grant operations might be POST, PUT, or PATCH
- Revoke might be DELETE or might require setting a field to null
- Some APIs are idempotent, some error on duplicate grants
- Error messages are often unhelpful

**What helps:**
- Test provisioning in a sandbox environment first
- Implement `Grant` and `Revoke` carefully - they're more important than `List`
- Return clear error messages so operators can debug
- Consider what happens if the operation partially succeeds

## Testing without a real environment

You want fast iteration, but connectors need real APIs to test against.

**The challenge:**
- Setting up test accounts takes time
- Test data might not cover edge cases
- API rate limits slow down testing
- Some features are only available on paid tiers

**What helps:**
- Use `--base-url` to point at mock servers during development
- The SDK's `--insecure` flag helps with local HTTPS mocks
- Build a small set of "golden" test accounts with known data
- Mock the API client for unit tests, use real APIs for integration tests

## Knowing when you're done

It's hard to know if your connector covers everything.

**The challenge:**
- Did you miss a resource type?
- Are there entitlements you didn't model?
- What about edge cases - disabled users, nested groups, inherited permissions?

**What helps:**
- Compare your connector's output to what the admin UI shows
- Check that every UI action has a corresponding sync or provision operation
- Test with real customer data (anonymized) if possible
- Accept that v1 won't be perfect - ship and iterate

## Getting help

You're not alone. Connector development has a learning curve, but others have been through it.

- **GitHub Discussions:** Ask questions, share patterns
- **Existing connectors:** Read the code of similar connectors
- **This documentation:** We're adding more examples and guides

The goal isn't to make connector development trivial - it's inherently complex because access models are complex. The goal is to make the complexity manageable.

## See also

- [Common gotchas](/developer/common-gotchas) - Code-level issues that trip up developers
- [Completeness checklist](/developer/completeness-checklist) - Verify your connector is complete
